# Supported expressions for database queries {#sec-tidyverse_expressions}

In the previous chapter, @sec-tidyverse_verbs, we saw that there are a core set of tidyverse functions that can be used with databases to extract data for analysis. The SQL code used in the previous chapter is consistent across database management systems, since it only involves basic operations such as joins and variable selection.

For more complex data pipelines, we will, however, often need to incorporate additional expressions within these functions. Because of differences across database management systems, the translated SQL can vary. Moreover, and something we need to keep in mind when working with multiple data partners, some expressions are only supported for some databases. When writing code that should work across different database management systems, we need to keep in mind which expressions are supported where. To help with this, the sections below show the available SQL translations for common expressions we might want to use.

Let's first load the packages which these expressions come from. In addition to base R types, [`bit64`](https://bit64.r-lib.org) adds support for integer64. The [`stringr`](https://stringr.tidyverse.org) package provides functions for working with strings, while [`clock`](https://clock.r-lib.org) has various functions for working with dates. Many other useful expressions will come from [`dplyr`](https://dplyr.tidyverse.org) itself.

```{r, warning=FALSE, message=FALSE, error=TRUE}
library(duckdb)
library(bit64)
library(dplyr)
library(dbplyr)
library(stringr)
library(clock)
```

## Data types

Commonly used data types are consistently supported across database backends. We can use the base [`as.numeric()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/numeric), [`as.integer()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/integer), [`as.character()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/character), [`as.Date()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/as.Date), and [`as.POSIXct()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/as.POSIX*). We can also use [`as.integer64()`](https://bit64.r-lib.org/reference/as.integer64.character.html) from the [`bit64`](https://bit64.r-lib.org) package to coerce to integer64, and the [`as_date()`](https://clock.r-lib.org/reference/as_date.html) and [`as_datetime()`](https://clock.r-lib.org/reference/as_date_time.html) from the [`clock`](https://clock.r-lib.org) package instead of [`as.Date()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/as.Date) and [`as.POSIXct()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/as.POSIX*), respectively.

::: {.callout-tip collapse="true"}
### Show SQL

::: panel-tabset
### DuckDB

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_duckdb()
translate_sql(as.numeric(var), con = con)
translate_sql(as.integer(var), con = con)
translate_sql(as.integer64(var), con = con)
translate_sql(as.character(var), con = con)
translate_sql(as.Date(var), con = con)
translate_sql(as_date(var), con = con)
translate_sql(as.POSIXct(var), con = con)
translate_sql(as_datetime(var), con = con)
translate_sql(as.logical(var), con = con)
```

### Postgres

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_postgres()
translate_sql(as.numeric(var), con = con)
translate_sql(as.integer(var), con = con)
translate_sql(as.integer64(var), con = con)
translate_sql(as.character(var), con = con)
translate_sql(as.Date(var), con = con)
translate_sql(as_date(var), con = con)
translate_sql(as.POSIXct(var), con = con)
translate_sql(as_datetime(var), con = con)
translate_sql(as.logical(var), con = con)
```

### SQL Server

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_mssql()
translate_sql(as.numeric(var), con = con)
translate_sql(as.integer(var), con = con)
translate_sql(as.integer64(var), con = con)
translate_sql(as.character(var), con = con)
translate_sql(as.Date(var), con = con)
translate_sql(as_date(var), con = con)
translate_sql(as.POSIXct(var), con = con)
translate_sql(as_datetime(var), con = con)
translate_sql(as.logical(var), con = con)
```

### Redshift

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_redshift()
translate_sql(as.numeric(var), con = con)
translate_sql(as.integer(var), con = con)
translate_sql(as.integer64(var), con = con)
translate_sql(as.character(var), con = con)
translate_sql(as.Date(var), con = con)
translate_sql(as_date(var), con = con)
translate_sql(as.POSIXct(var), con = con)
translate_sql(as_datetime(var), con = con)
translate_sql(as.logical(var), con = con)
```

### Snowflake

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_snowflake()
translate_sql(as.numeric(var), con = con)
translate_sql(as.integer(var), con = con)
translate_sql(as.integer64(var), con = con)
translate_sql(as.character(var), con = con)
translate_sql(as.Date(var), con = con)
translate_sql(as_date(var), con = con)
translate_sql(as.POSIXct(var), con = con)
translate_sql(as_datetime(var), con = con)
translate_sql(as.logical(var), con = con)
```

### Spark

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_spark_sql()
translate_sql(as.numeric(var), con = con)
translate_sql(as.integer(var), con = con)
translate_sql(as.integer64(var), con = con)
translate_sql(as.character(var), con = con)
translate_sql(as.Date(var), con = con)
translate_sql(as_date(var), con = con)
translate_sql(as.POSIXct(var), con = con)
translate_sql(as_datetime(var), con = con)
translate_sql(as.logical(var), con = con)
```
:::
:::

## Comparison and logical operators

Base R comparison operators, such as `<`, `<=`, `==`, `>=`, `>`, are also well supported in all database backends. Logical operators, such as `&` and `|`, can also be used as if the data were in R.

::: {.callout-tip collapse="true"}
### Show SQL

::: {.panel-tabset collapse="true"}
### DuckDB

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_duckdb()
translate_sql(var_1 == var_2, con = con)
translate_sql(var_1 >= var_2, con = con)
translate_sql(var_1 < 100, con = con)
translate_sql(var_1 %in% c("a", "b", "c"), con = con)
translate_sql(!var_1 %in% c("a", "b", "c"), con = con)
translate_sql(is.na(var_1), con = con)
translate_sql(!is.na(var_1), con = con)
translate_sql(var_1 >= 100 & var_1 < 200, con = con)
translate_sql(var_1 >= 100 | var_1 < 200, con = con)
```

### Postgres

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_postgres()
translate_sql(var_1 == var_2, con = con)
translate_sql(var_1 >= var_2, con = con)
translate_sql(var_1 < 100, con = con)
translate_sql(var_1 %in% c("a", "b", "c"), con = con)
translate_sql(!var_1 %in% c("a", "b", "c"), con = con)
translate_sql(is.na(var_1), con = con)
translate_sql(!is.na(var_1), con = con)
translate_sql(var_1 >= 100 & var_1 < 200, con = con)
translate_sql(var_1 >= 100 | var_1 < 200, con = con)
```

### SQL Server

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_mssql()
translate_sql(var_1 == var_2, con = con)
translate_sql(var_1 >= var_2, con = con)
translate_sql(var_1 < 100, con = con)
translate_sql(var_1 %in% c("a", "b", "c"), con = con)
translate_sql(!var_1 %in% c("a", "b", "c"), con = con)
translate_sql(is.na(var_1), con = con)
translate_sql(!is.na(var_1), con = con)
translate_sql(var_1 >= 100 & var_1 < 200, con = con)
translate_sql(var_1 >= 100 | var_1 < 200, con = con)
```

### Redshift

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_redshift()
translate_sql(var_1 == var_2, con = con)
translate_sql(var_1 >= var_2, con = con)
translate_sql(var_1 < 100, con = con)
translate_sql(var_1 %in% c("a", "b", "c"), con = con)
translate_sql(!var_1 %in% c("a", "b", "c"), con = con)
translate_sql(is.na(var_1), con = con)
translate_sql(!is.na(var_1), con = con)
translate_sql(var_1 >= 100 & var_1 < 200, con = con)
translate_sql(var_1 >= 100 | var_1 < 200, con = con)
```

### Snowflake

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_snowflake()
translate_sql(var_1 == var_2, con = con)
translate_sql(var_1 >= var_2, con = con)
translate_sql(var_1 < 100, con = con)
translate_sql(var_1 %in% c("a", "b", "c"), con = con)
translate_sql(!var_1 %in% c("a", "b", "c"), con = con)
translate_sql(is.na(var_1), con = con)
translate_sql(!is.na(var_1), con = con)
translate_sql(var_1 >= 100 & var_1 < 200, con = con)
translate_sql(var_1 >= 100 | var_1 < 200, con = con)
```

### Spark

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_spark_sql()
translate_sql(var_1 == var_2, con = con)
translate_sql(var_1 >= var_2, con = con)
translate_sql(var_1 < 100, con = con)
translate_sql(var_1 %in% c("a", "b", "c"), con = con)
translate_sql(!var_1 %in% c("a", "b", "c"), con = con)
translate_sql(is.na(var_1), con = con)
translate_sql(!is.na(var_1), con = con)
translate_sql(var_1 >= 100 & var_1 < 200, con = con)
translate_sql(var_1 >= 100 | var_1 < 200, con = con)
```
:::
:::

## Conditional statements

The base `ifelse` function, along with `if_else` and `case_when` from `dplyr` are translated for each database backend. As can be seen in the translations, `case_when` maps to the SQL CASE WHEN statement.

::: {.callout-tip collapse="true"}
### Show SQL

::: {.panel-tabset collapse="true"}
### DuckDB

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_duckdb()
translate_sql(ifelse(var == "a", 1L, 2L), con = con)
translate_sql(if_else(var == "a", 1L, 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, .default = 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = NULL), 
              con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = "something else"), 
              con = con)
```

### Postgres

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_postgres()
translate_sql(ifelse(var == "a", 1L, 2L), con = con)
translate_sql(if_else(var == "a", 1L, 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, .default = 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = NULL), 
              con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = "something else"), 
              con = con)
```

### SQL Server

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_mssql()
translate_sql(ifelse(var == "a", 1L, 2L), con = con)
translate_sql(if_else(var == "a", 1L, 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, .default = 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = NULL), 
              con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = "something else"), 
              con = con)
```

### Redshift

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_redshift()
translate_sql(ifelse(var == "a", 1L, 2L), con = con)
translate_sql(if_else(var == "a", 1L, 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, .default = 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = NULL), 
              con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = "something else"), 
              con = con)
```

### Snowflake

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_snowflake()
translate_sql(ifelse(var == "a", 1L, 2L), con = con)
translate_sql(if_else(var == "a", 1L, 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, .default = 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = NULL), 
              con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = "something else"), 
              con = con)
```

### Spark

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_spark_sql()
translate_sql(ifelse(var == "a", 1L, 2L), con = con)
translate_sql(if_else(var == "a", 1L, 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, .default = 2L), con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = NULL), 
              con = con)
translate_sql(case_when(var == "a" ~ 1L, var == "b" ~ 2L, var == "c" ~ 3L, 
                        .default = "something else"), 
              con = con)
```
:::
:::

## Working with dates

When working with dates we can mostly rely on functions from the `clock` package such as `get_day()`, `get_month()`, `get_year()` to extract parts from a date, `add_days()` to add or subtract days to a date, and `date_count_between()` to get the number of days between two date variables. Note when counting time betweem two dates only difference in days is well supported (but we can always use these to calculate differences in years, for example, subsequently).  

::: {.callout-tip collapse="true"}
### Show SQL

::: {.panel-tabset collapse="true"}
### DuckDB

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_duckdb()
translate_sql(get_day(date_1), con = con)
translate_sql(get_month(date_1), con = con)
translate_sql(get_year(date_1), con = con)
translate_sql(add_days(date_1, 1), con = con)
translate_sql(add_years(date_1, 1), con = con)
translate_sql(date_count_between(date_1, date_2, "day"), con = con)
```

### Postgres

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_postgres()
translate_sql(get_day(date_1), con = con)
translate_sql(get_month(date_1), con = con)
translate_sql(get_year(date_1), con = con)
translate_sql(add_days(date_1, 1), con = con)
translate_sql(add_years(date_1, 1), con = con)
translate_sql(date_count_between(date_1, date_2, "day"), con = con)
```

### SQL Server

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_mssql()
translate_sql(get_day(date_1), con = con)
translate_sql(get_month(date_1), con = con)
translate_sql(get_year(date_1), con = con)
translate_sql(add_days(date_1, 1), con = con)
translate_sql(add_years(date_1, 1), con = con)
translate_sql(date_count_between(date_1, date_2, "day"), con = con)
```

### Redshift

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_redshift()
translate_sql(get_day(date_1), con = con)
translate_sql(get_month(date_1), con = con)
translate_sql(get_year(date_1), con = con)
translate_sql(add_days(date_1, 1), con = con)
translate_sql(add_years(date_1, 1), con = con)
translate_sql(date_count_between(date_1, date_2, "day"), con = con)
```

### Snowflake

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_snowflake()
translate_sql(get_day(date_1), con = con)
translate_sql(get_month(date_1), con = con)
translate_sql(get_year(date_1), con = con)
translate_sql(add_days(date_1, 1), con = con)
translate_sql(add_years(date_1, 1), con = con)
translate_sql(date_count_between(date_1, date_2, "day"), con = con)
```

### Spark

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_spark_sql()
translate_sql(get_day(date_1), con = con)
translate_sql(get_month(date_1), con = con)
translate_sql(get_year(date_1), con = con)
translate_sql(add_days(date_1, 1), con = con)
translate_sql(add_years(date_1, 1), con = con)
translate_sql(date_count_between(date_1, date_2, "day"), con = con)
```
:::
:::



## Working with strings

Compared to the previous sections, there is much more variation in support of functions to work with strings across database management systems. In particular, although various useful `stringr` functions do have comprehensive translations, it can be seen below that more translations are available for some databases compared to others.

::: {.callout-tip collapse="true"}
### Show SQL

::: {.panel-tabset collapse="true"}
### DuckDB

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_duckdb()
translate_sql(nchar(var), con = con)
translate_sql(nzchar(var), con = con)
translate_sql(substr(var, 1, 2), con = con)
translate_sql(trimws(var), con = con)
translate_sql(tolower(var), con = con)
translate_sql(str_to_lower(var), con = con)
translate_sql(toupper(var), con = con)
translate_sql(str_to_upper(var), con = con)
translate_sql(str_to_title(var), con = con)
translate_sql(str_trim(var), con = con)
translate_sql(str_squish(var), con = con)
translate_sql(str_detect(var, "b"), con = con)
translate_sql(str_detect(var, "b", negate = TRUE), con = con)
translate_sql(str_detect(var, "[aeiou]"), con = con)
translate_sql(str_replace(var, "a", "b"), con = con)
translate_sql(str_replace_all(var, "a", "b"), con = con)
translate_sql(str_remove(var, "a"), con = con)
translate_sql(str_remove_all(var, "a"), con = con)
translate_sql(str_like(var, "a"), con = con)
translate_sql(str_starts(var, "a"), con = con)
translate_sql(str_ends(var, "a"), con = con)
```

### Postgres

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_postgres()
translate_sql(nchar(var), con = con)
translate_sql(nzchar(var), con = con)
translate_sql(substr(var, 1, 2), con = con)
translate_sql(trimws(var), con = con)
translate_sql(tolower(var), con = con)
translate_sql(str_to_lower(var), con = con)
translate_sql(toupper(var), con = con)
translate_sql(str_to_upper(var), con = con)
translate_sql(str_to_title(var), con = con)
translate_sql(str_trim(var), con = con)
translate_sql(str_squish(var), con = con)
translate_sql(str_detect(var, "b"), con = con)
translate_sql(str_detect(var, "b", negate = TRUE), con = con)
translate_sql(str_detect(var, "[aeiou]"), con = con)
translate_sql(str_replace(var, "a", "b"), con = con)
translate_sql(str_replace_all(var, "a", "b"), con = con)
translate_sql(str_remove(var, "a"), con = con)
translate_sql(str_remove_all(var, "a"), con = con)
translate_sql(str_like(var, "a"), con = con)
translate_sql(str_starts(var, "a"), con = con)
translate_sql(str_ends(var, "a"), con = con)
```

### SQL Server

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_mssql()
translate_sql(nchar(var), con = con)
translate_sql(nzchar(var), con = con)
translate_sql(substr(var, 1, 2), con = con)
translate_sql(trimws(var), con = con)
translate_sql(tolower(var), con = con)
translate_sql(str_to_lower(var), con = con)
translate_sql(toupper(var), con = con)
translate_sql(str_to_upper(var), con = con)
translate_sql(str_to_title(var), con = con)
translate_sql(str_trim(var), con = con)
translate_sql(str_squish(var), con = con)
translate_sql(str_detect(var, "b"), con = con)
translate_sql(str_detect(var, "b", negate = TRUE), con = con)
translate_sql(str_detect(var, "[aeiou]"), con = con)
translate_sql(str_replace(var, "a", "b"), con = con)
translate_sql(str_replace_all(var, "a", "b"), con = con)
translate_sql(str_remove(var, "a"), con = con)
translate_sql(str_remove_all(var, "a"), con = con)
translate_sql(str_like(var, "a"), con = con)
translate_sql(str_starts(var, "a"), con = con)
translate_sql(str_ends(var, "a"), con = con)
```

### Redshift

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_redshift()
translate_sql(nchar(var), con = con)
translate_sql(nzchar(var), con = con)
translate_sql(substr(var, 1, 2), con = con)
translate_sql(trimws(var), con = con)
translate_sql(tolower(var), con = con)
translate_sql(str_to_lower(var), con = con)
translate_sql(toupper(var), con = con)
translate_sql(str_to_upper(var), con = con)
translate_sql(str_to_title(var), con = con)
translate_sql(str_trim(var), con = con)
translate_sql(str_squish(var), con = con)
translate_sql(str_detect(var, "b"), con = con)
translate_sql(str_detect(var, "b", negate = TRUE), con = con)
translate_sql(str_detect(var, "[aeiou]"), con = con)
translate_sql(str_replace(var, "a", "b"), con = con)
translate_sql(str_replace_all(var, "a", "b"), con = con)
translate_sql(str_remove(var, "a"), con = con)
translate_sql(str_remove_all(var, "a"), con = con)
translate_sql(str_like(var, "a"), con = con)
translate_sql(str_starts(var, "a"), con = con)
translate_sql(str_ends(var, "a"), con = con)
```

### Snowflake

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_snowflake()
translate_sql(nchar(var), con = con)
translate_sql(nzchar(var), con = con)
translate_sql(substr(var, 1, 2), con = con)
translate_sql(trimws(var), con = con)
translate_sql(tolower(var), con = con)
translate_sql(str_to_lower(var), con = con)
translate_sql(toupper(var), con = con)
translate_sql(str_to_upper(var), con = con)
translate_sql(str_to_title(var), con = con)
translate_sql(str_trim(var), con = con)
translate_sql(str_squish(var), con = con)
translate_sql(str_detect(var, "b"), con = con)
translate_sql(str_detect(var, "b", negate = TRUE), con = con)
translate_sql(str_detect(var, "[aeiou]"), con = con)
translate_sql(str_replace(var, "a", "b"), con = con)
translate_sql(str_replace_all(var, "a", "b"), con = con)
translate_sql(str_remove(var, "a"), con = con)
translate_sql(str_remove_all(var, "a"), con = con)
translate_sql(str_like(var, "a"), con = con)
translate_sql(str_starts(var, "a"), con = con)
translate_sql(str_ends(var, "a"), con = con)
```

### Spark

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_spark_sql()
translate_sql(nchar(var), con = con)
translate_sql(nzchar(var), con = con)
translate_sql(substr(var, 1, 2), con = con)
translate_sql(trimws(var), con = con)
translate_sql(tolower(var), con = con)
translate_sql(str_to_lower(var), con = con)
translate_sql(toupper(var), con = con)
translate_sql(str_to_upper(var), con = con)
translate_sql(str_to_title(var), con = con)
translate_sql(str_trim(var), con = con)
translate_sql(str_squish(var), con = con)
translate_sql(str_detect(var, "b"), con = con)
translate_sql(str_detect(var, "b", negate = TRUE), con = con)
translate_sql(str_detect(var, "[aeiou]"), con = con)
translate_sql(str_replace(var, "a", "b"), con = con)
translate_sql(str_replace_all(var, "a", "b"), con = con)
translate_sql(str_remove(var, "a"), con = con)
translate_sql(str_remove_all(var, "a"), con = con)
translate_sql(str_like(var, "a"), con = con)
translate_sql(str_starts(var, "a"), con = con)
translate_sql(str_ends(var, "a"), con = con)
```
:::
:::

## Data aggregation

Within the context of using `summarise()`, we can get aggregated results across entire columns using functions such as `n()`, `n_distinct()`, `sum()`, `min()`, `max()`, `mean()`, and `sd()`. As can be seen below, the SQL for these calculations is similar across different database management systems.

::: {.callout-tip collapse="true"}
### Show SQL

::: {.panel-tabset collapse="true"}
### DuckDB

```{r, message=FALSE, warning=FALSE, error=TRUE}
lazy_frame(x = c(1, 2), con = simulate_duckdb()) |>
  summarise(
    n = n(),
    n_unique = n_distinct(x),
    sum = sum(x, na.rm = TRUE),
    sum_is_1 = sum(x == 1, na.rm = TRUE),
    min = min(x, na.rm = TRUE),
    mean = mean(x, na.rm = TRUE),
    max = max(x, na.rm = TRUE),
    sd = sd(x, na.rm = TRUE)
  ) |> 
  show_query()
```

### Postgres

```{r, message=FALSE, warning=FALSE, error=TRUE}
lazy_frame(x = c(1, 2), con = simulate_postgres()) |>
  summarise(
    n = n(),
    n_unique = n_distinct(x),
    sum = sum(x, na.rm = TRUE),
    sum_is_1 = sum(x == 1, na.rm = TRUE),
    min = min(x, na.rm = TRUE),
    mean = mean(x, na.rm = TRUE),
    max = max(x, na.rm = TRUE),
    sd = sd(x, na.rm = TRUE)
  ) |> 
  show_query()
```

### SQL Server

```{r, message=FALSE, warning=FALSE, error=TRUE}
lazy_frame(x = c(1, 2), con = simulate_mssql()) |>
  summarise(
    n = n(),
    n_unique = n_distinct(x),
    sum = sum(x, na.rm = TRUE),
    sum_is_1 = sum(x == 1, na.rm = TRUE),
    min = min(x, na.rm = TRUE),
    mean = mean(x, na.rm = TRUE),
    max = max(x, na.rm = TRUE),
    sd = sd(x, na.rm = TRUE)
  ) |> 
  show_query()
```

### Redshift

```{r, message=FALSE, warning=FALSE, error=TRUE}
lazy_frame(x = c(1, 2), con = simulate_redshift()) |>
  summarise(
    n = n(),
    n_unique = n_distinct(x),
    sum = sum(x, na.rm = TRUE),
    sum_is_1 = sum(x == 1, na.rm = TRUE),
    min = min(x, na.rm = TRUE),
    mean = mean(x, na.rm = TRUE),
    max = max(x, na.rm = TRUE),
    sd = sd(x, na.rm = TRUE)
  ) |> 
  show_query()
```

### Snowflake

```{r, message=FALSE, warning=FALSE, error=TRUE}
lazy_frame(x = c(1, 2), con = simulate_snowflake()) |>
  summarise(
    n = n(),
    n_unique = n_distinct(x),
    sum = sum(x, na.rm = TRUE),
    sum_is_1 = sum(x == 1, na.rm = TRUE),
    min = min(x, na.rm = TRUE),
    mean = mean(x, na.rm = TRUE),
    max = max(x, na.rm = TRUE),
    sd = sd(x, na.rm = TRUE)
  ) |> 
  show_query()
```

### Spark

```{r, message=FALSE, warning=FALSE, error=TRUE}
lazy_frame(x = c(1, 2), con = simulate_spark_sql()) |>
  summarise(
    n = n(),
    n_unique = n_distinct(x),
    sum = sum(x, na.rm = TRUE),
    sum_is_1 = sum(x == 1, na.rm = TRUE),
    min = min(x, na.rm = TRUE),
    mean = mean(x, na.rm = TRUE),
    max = max(x, na.rm = TRUE),
    sd = sd(x, na.rm = TRUE)
  ) |> 
  show_query()
```
:::
:::

## Window functions

Window functions differ from data aggregation functions in that they perform calculations across rows that are related to the current row, rather than collapsing multiple rows into a single result. For these operations, we use `mutate()` instead of `summarise()`.

For instance, we can use window functions like `cumsum()` and `cummean()` to calculate running totals and averages, or `lag()` and `lead()` to help compare rows to their preceding or following rows.

Given that window functions compare rows to rows before or after them, we will often use `arrange()` or `window_order()` to specify the order of rows. This will translate into an ORDER BY clause in the SQL. In addition, we may well also want to apply window functions within some specific groupings in our data. Using `group_by()` would result in a PARTITION BY clause in the translated SQL so that the window function operates on each group independently.

::: {.callout-tip collapse="true"}
### Show SQL

::: {.panel-tabset collapse="true"}
### DuckDB

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_duckdb()
lazy_frame(x = c(10, 20, 30), z = c(1, 2, 3), con = con) |> 
  window_order(z) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
lazy_frame(x = c(10, 20), y = c("a", "b"), z = c(1, 2), con = con) |>
  window_order(z) |> 
  group_by(y) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
```

### Postgres

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_postgres()
lazy_frame(x = c(10, 20, 30), z = c(1, 2, 3), con = con) |> 
  window_order(z) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
lazy_frame(x = c(10, 20), y = c("a", "b"), z = c(1, 2), con = con) |>
  window_order(z) |> 
  group_by(y) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
```

### SQL Server

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_mssql()
lazy_frame(x = c(10, 20, 30), z = c(1, 2, 3), con = con) |> 
  window_order(z) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
lazy_frame(x = c(10, 20), y = c("a", "b"), z = c(1, 2), con = con) |>
  window_order(z) |> 
  group_by(y) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
```

### Redshift

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_redshift()
lazy_frame(x = c(10, 20, 30), z = c(1, 2, 3), con = con) |> 
  window_order(z) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
lazy_frame(x = c(10, 20), y = c("a", "b"), z = c(1, 2), con = con) |>
  window_order(z) |> 
  group_by(y) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
```

### Snowflake

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_snowflake()
lazy_frame(x = c(10, 20, 30), z = c(1, 2, 3), con = con) |> 
  window_order(z) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
lazy_frame(x = c(10, 20), y = c("a", "b"), z = c(1, 2), con = con) |>
  window_order(z) |> 
  group_by(y) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
```

### Spark

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_spark_sql()
lazy_frame(x = c(10, 20, 30), z = c(1, 2, 3), con = con) |> 
  window_order(z) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
lazy_frame(x = c(10, 20), y = c("a", "b"), z = c(1, 2), con = con) |>
  window_order(z) |> 
  group_by(y) |> 
  mutate(
    sum_x = cumsum(x),
    mean_x = cummean(x),
    lag_x = lag(x), 
    lead_x = lead(x)
  ) |> 
  show_query()
```
:::
:::

::: {.callout-note collapse="true"}
### `arrange()` vs `window_order()`

Although `arrange()` and `window_order()` both involve ordering, they serve different purposes.

- **`arrange()`:** changes the order of the final output of a table, by ordering it as the user specified. 

- **`window_order()`:** defines the order within window functions. It controls how functions (e.g., `lag()`, `lead()`, `rank()`, `cumsum()`) are applied across rows.

In conclusion, for all dialects, `arrange()` changes the output row order, while `window_order()` changes how window functions calculate values. 

:::

## Calculating quantiles, including the median

So far we've seen that we can perform various data manipulations and calculate summary statistics for different database management systems using the same R code. Although the translated SQL has been different, the databases all supported similar approaches to perform these queries.

A case where this is not true is when we are interested in summarising distributions of the data and estimating quantiles. For example, let's take estimating the median as an example. Some databases only support calculating the median as an aggregation function similar to how min, mean, and max were calculated above. However, some others only support it as a window function like lead and lag above. Unfortunately, this means that for some databases, quantiles can only be calculated using the summarise aggregation approach, while in others only the mutate window approach can be used.

::: {.callout-tip collapse="true"}
### Show SQL

::: {.panel-tabset collapse="true"}
### DuckDB

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_duckdb()
lazy_frame(x = c(1, 2), con = con) |>
  summarise(median = median(x, na.rm = TRUE)) |> 
  show_query()
lazy_frame(x = c(1, 2), con = con) |>
  mutate(median = median(x, na.rm = TRUE)) |> 
  show_query()
```

### Postgres

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_postgres()
lazy_frame(x = c(1, 2), con = con) |>
  summarise(median = median(x, na.rm = TRUE)) |> 
  show_query()
lazy_frame(x = c(1, 2), con = con) |>
  mutate(median = median(x, na.rm = TRUE)) |> 
  show_query()
```

### SQL Server

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_mssql()
lazy_frame(x = c(1, 2), con = con) |>
  summarise(median = median(x, na.rm = TRUE)) |> 
  show_query()
lazy_frame(x = c(1, 2), con = con) |>
  mutate(median = median(x, na.rm = TRUE)) |> 
  show_query()
```

### Redshift

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_redshift()
lazy_frame(x = c(1, 2), con = con) |>
  summarise(median = median(x, na.rm = TRUE)) |> 
  show_query()
lazy_frame(x = c(1, 2), con = con) |>
  mutate(median = median(x, na.rm = TRUE)) |> 
  show_query()
```

### Snowflake

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_snowflake()
lazy_frame(x = c(1, 2), con = con) |>
  summarise(median = median(x, na.rm = TRUE)) |> 
  show_query()
lazy_frame(x = c(1, 2), con = con) |>
  mutate(median = median(x, na.rm = TRUE)) |> 
  show_query()
```

### Spark

```{r, message=FALSE, warning=FALSE, error=TRUE}
con <- simulate_spark_sql()
lazy_frame(x = c(1, 2), con = con) |>
  summarise(median = median(x, na.rm = TRUE)) |> 
  show_query()
lazy_frame(x = c(1, 2), con = con) |>
  mutate(median = median(x, na.rm = TRUE)) |> 
  show_query()
```
:::
:::
