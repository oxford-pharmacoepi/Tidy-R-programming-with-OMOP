{
  "hash": "4619eaa8c2d11c3dcc62711a80aae9aa",
  "result": {
    "engine": "knitr",
    "markdown": "## Exploring the OMOP CDM\n\nFor this chapter, lets again use the synthetic COVID-19 dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(dbplyr)\nlibrary(dplyr)\nlibrary(here)\nlibrary(CDMConnector)\nlibrary(ggplot2)\nlibrary(clock)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndb<-dbConnect(duckdb::duckdb(), \n              dbdir = eunomiaDir(datasetName = \"synthea-covid19-10k\"))\ncdm <- cdm_from_con(db, cdm_schema = \"main\", write_schema = \"main\")\n```\n:::\n\n\n## Counting people\n\nThe OMOP CDM is person-centric, with the person table containing records to uniquely identify each person in the database. As each row refers to a unique person, we can quickly get a count of the number of individuals in the database like so\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person |> \n  count() |> \n  pull()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10754\n```\n\n\n:::\n:::\n\n\nThe person table also contains some demographic information, including a gender concept for each person. We can get a count grouped by this variable, but as this uses a concept we'll also need to join to the concept table to get the corresponding concept name for each concept id.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person |> \n  group_by(gender_concept_id) |> \n  count() |> \n  left_join(cdm$concept, \n            by=c(\"gender_concept_id\" = \"concept_id\")) |> \n              select(\"gender_concept_id\", \"concept_name\", \"n\") |> \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n# Groups:   gender_concept_id [2]\n  gender_concept_id concept_name     n\n              <int> <chr>        <dbl>\n1              8532 FEMALE        5165\n2              8507 MALE          5589\n```\n\n\n:::\n:::\n\n\nThe observation period table contains records indicating spans of time over which clinical events can be reliably observed for the people in the person table. Someone can potentially have multiple observation periods. So say we wanted a count of people grouped by the year during which their first observation period started. We could do this like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_observation_period <- cdm$observation_period |>\n    group_by(person_id) |> \n    filter(row_number() == 1) |> \n    compute()\n\ncdm$person |> \n  left_join(first_observation_period,\n            by = \"person_id\") |> \n  mutate(observation_period_start_year = get_year(observation_period_start_date)) |> \n  group_by(observation_period_start_year) |> \n  count() |> \n  collect() |> \n  ggplot() +\n  geom_col(aes(observation_period_start_year, n)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Computing intermediate queries\n\nThe compute() function will force the computation of a query (by default to a temporary table in the database). In the example above we use it to split up two queries; the first to keep the first observation period record for each individual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period |>\n    group_by(person_id) |> \n    filter(row_number() == 1) |> \n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT\n  observation_period_id,\n  person_id,\n  observation_period_start_date,\n  observation_period_end_date,\n  period_type_concept_id\nFROM (\n  SELECT\n    observation_period.*,\n    ROW_NUMBER() OVER (PARTITION BY person_id) AS col01\n  FROM main.observation_period\n) q01\nWHERE (col01 = 1.0)\n```\n\n\n:::\n:::\n\n\nFollowed by a second query that left joins the person table with the result from the first (which is now in a temporary table), followed by extracted the year in which peoples first observation period starts and then, finally, a count by year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person |> \n  left_join(first_observation_period,\n            by = \"person_id\") |> \n  mutate(observation_period_start_year=year(observation_period_start_date)) |> \n  group_by(observation_period_start_year) |> \n  count() |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT observation_period_start_year, COUNT(*) AS n\nFROM (\n  SELECT\n    q01.*,\n    EXTRACT(year FROM observation_period_start_date) AS observation_period_start_year\n  FROM (\n    SELECT\n      person.*,\n      observation_period_id,\n      observation_period_start_date,\n      observation_period_end_date,\n      period_type_concept_id\n    FROM main.person\n    LEFT JOIN og_001_1721383787\n      ON (person.person_id = og_001_1721383787.person_id)\n  ) q01\n) q01\nGROUP BY observation_period_start_year\n```\n\n\n:::\n:::\n\n\nWe could, however, have done this without compute, with instead the SQL being done all at once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person |> \n  left_join(cdm$observation_period |>\n    group_by(person_id) |> \n    filter(row_number() == 1),\n            by = \"person_id\") |> \n  mutate(observation_period_start_year=year(observation_period_start_date)) |> \n  group_by(observation_period_start_year) |> \n  count() |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT observation_period_start_year, COUNT(*) AS n\nFROM (\n  SELECT\n    q01.*,\n    EXTRACT(year FROM observation_period_start_date) AS observation_period_start_year\n  FROM (\n    SELECT\n      person.*,\n      observation_period_id,\n      observation_period_start_date,\n      observation_period_end_date,\n      period_type_concept_id\n    FROM main.person\n    LEFT JOIN (\n      SELECT\n        observation_period_id,\n        person_id,\n        observation_period_start_date,\n        observation_period_end_date,\n        period_type_concept_id\n      FROM (\n        SELECT\n          observation_period.*,\n          ROW_NUMBER() OVER (PARTITION BY person_id) AS col01\n        FROM main.observation_period\n      ) q01\n      WHERE (col01 = 1.0)\n    ) RHS\n      ON (person.person_id = RHS.person_id)\n  ) q01\n) q01\nGROUP BY observation_period_start_year\n```\n\n\n:::\n:::\n\n\nIn this case the SQL is not much more complicated than before. However, you can imagine that without using computation to intermediate tables, the SQL associated with a series of data manipulations could quickly become unmanageable. Although we don't want to overuse computation of intermediate queries, it is often a necessity when writing study analysis scripts.\n\nA particular advantage of computing a query, is that we can then use the result for multiple subsequent queries. For example, say we want a count of condition occurrence and drug exposure records for those born before 1970. We could get these counts independently:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person |> \n  filter(year_of_birth < \"1970\") |> \n  select(\"person_id\") |> \n  left_join(cdm$condition_occurrence,\n            by=\"person_id\") |> \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmpq2lXaR\\file59a87f39708e.duckdb]\n      n\n  <dbl>\n1  9305\n```\n\n\n:::\n\n```{.r .cell-code}\ncdm$person |> \n  filter(year_of_birth < \"1970\") |> \n  select(\"person_id\") |> \n  left_join(cdm$drug_exposure,\n            by=\"person_id\") |> \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmpq2lXaR\\file59a87f39708e.duckdb]\n       n\n   <dbl>\n1 165681\n```\n\n\n:::\n:::\n\n\nBut we could have instead first subsetted the person table and then used the result for both queries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person_pre_1970 <- cdm$person |> \n  filter(year_of_birth < \"1970\") |> \n  compute()\n\ncdm$person_pre_1970 |> \n  select(\"person_id\") |> \n  left_join(cdm$condition_occurrence,\n            by=\"person_id\") |> \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmpq2lXaR\\file59a87f39708e.duckdb]\n      n\n  <dbl>\n1  9305\n```\n\n\n:::\n\n```{.r .cell-code}\ncdm$person_pre_1970 |> \n  select(\"person_id\") |> \n  left_join(cdm$drug_exposure,\n            by=\"person_id\") |> \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmpq2lXaR\\file59a87f39708e.duckdb]\n       n\n   <dbl>\n1 165681\n```\n\n\n:::\n:::\n\n:::\n\n## Counting records\n\nWhat's the number of condition occurrence records per person in the database? We can find this out like so\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person |> \n  left_join(cdm$condition_occurrence |> \n  group_by(person_id) |> \n  count(name = \"condition_occurrence_records\"),\n  by=\"person_id\") |> \n  mutate(condition_occurrence_records = if_else(\n    is.na(condition_occurrence_records), 0,\n    condition_occurrence_records)) |> \n  group_by(condition_occurrence_records) |>\n  count() |> \n  collect() |> \n  ggplot() +\n  geom_col(aes(condition_occurrence_records, n)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nHow about we were interested in getting record counts for some specific concepts related to COVID-19 symptoms?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$condition_occurrence |> \n  filter(condition_concept_id %in% c(437663,437390,31967,\n                                     4289517,4223659, 312437,\n                                     434490,254761,77074)) |> \n  group_by(condition_concept_id) |> \n  count() |> \n  left_join(cdm$concept,\n            by=c(\"condition_concept_id\" = \"concept_id\")) |> \n  collect() |> \n  ggplot() +\n  geom_col(aes(concept_name, n)) +\n  theme_bw()+\n  xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Vocabulary tables\n\nAbove we've got counts by specific concept IDs recorded in the condition occurrence table. What these IDs represent is described in the concept table. Here we have the name associate with the concept, along with other information such as it's domain and vocabulary id.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$concept |> \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: ??\nColumns: 10\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmpq2lXaR\\file59a87f39708e.duckdb]\n$ concept_id       <int> 45756805, 45756804, 45756803, 45756802, 45756801, 457…\n$ concept_name     <chr> \"Pediatric Cardiology\", \"Pediatric Anesthesiology\", \"…\n$ domain_id        <chr> \"Provider\", \"Provider\", \"Provider\", \"Provider\", \"Prov…\n$ vocabulary_id    <chr> \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS…\n$ concept_class_id <chr> \"Physician Specialty\", \"Physician Specialty\", \"Physic…\n$ standard_concept <chr> \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\"…\n$ concept_code     <chr> \"OMOP4821938\", \"OMOP4821939\", \"OMOP4821940\", \"OMOP482…\n$ valid_start_date <date> 1970-01-01, 1970-01-01, 1970-01-01, 1970-01-01, 1970…\n$ valid_end_date   <date> 2099-12-31, 2099-12-31, 2099-12-31, 2099-12-31, 2099…\n$ invalid_reason   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n```\n\n\n:::\n:::\n\n\nOther vocabulary tables capture other information about concepts, such as the direct relationships between concepts (the concept relationship table) and hierarchical relationships between (the concept ancestor table).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$concept_relationship |> \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: ??\nColumns: 6\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmpq2lXaR\\file59a87f39708e.duckdb]\n$ concept_id_1     <int> 35804314, 35804314, 35804314, 35804327, 35804327, 358…\n$ concept_id_2     <int> 912065, 42542145, 42542145, 35803584, 42542145, 42542…\n$ relationship_id  <chr> \"Has modality\", \"Has accepted use\", \"Is current in\", …\n$ valid_start_date <date> 2021-01-26, 2019-08-29, 2019-08-29, 2019-05-27, 2019…\n$ valid_end_date   <date> 2099-12-31, 2099-12-31, 2099-12-31, 2099-12-31, 2099…\n$ invalid_reason   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n```\n\n\n:::\n\n```{.r .cell-code}\ncdm$concept_ancestor |> \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: ??\nColumns: 4\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmpq2lXaR\\file59a87f39708e.duckdb]\n$ ancestor_concept_id      <int> 375415, 727760, 735979, 438112, 529411, 14196…\n$ descendant_concept_id    <int> 4335743, 2056453, 41070383, 36566114, 4326940…\n$ min_levels_of_separation <int> 4, 1, 3, 2, 3, 3, 4, 3, 2, 5, 1, 3, 4, 2, 2, …\n$ max_levels_of_separation <int> 4, 1, 5, 3, 3, 6, 12, 3, 2, 10, 1, 3, 4, 2, 2…\n```\n\n\n:::\n:::\n\n\nMore information on the vocabulary tables (as well as other tables in the OMOP CDM version 5.3) can be found at <https://ohdsi.github.io/CommonDataModel/cdm53.html#Vocabulary_Tables>.\n:::\n\n## Working with dates\n\nWhen working with dates, the best supported functions come from the [clock](https://clock.r-lib.org/) package. In particular, a lot of the date manipulations we might be interested in can be achieved through the use of add_days (to add days to or subtract days from a date), add_years (same as add_days by with years as the timescale), and date_count_between (to get the difference between two dates). For example let's see how these can be applied to date fields in the observation period table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(clock)\nlibrary(ggplot2)\n\ncdm$observation_period |> \n  mutate(observation_period_start_plus_30_days = \n           add_days(observation_period_start_date, 30L),\n         observation_period_start_date_plus_10_years = \n           add_years(observation_period_start_date, 10L)) |> \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: ??\nColumns: 7\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmpq2lXaR\\file59a87f39708e.duckdb]\n$ observation_period_id                       <int> 1, 2, 3, 4, 5, 6, 7, 8, 9,…\n$ person_id                                   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9,…\n$ observation_period_start_date               <date> 2014-05-09, 1977-04-11, 2…\n$ observation_period_end_date                 <date> 2023-05-12, 1986-09-15, 2…\n$ period_type_concept_id                      <int> 44814724, 44814724, 448147…\n$ observation_period_start_plus_30_days       <dttm> 2014-06-08, 1977-05-11, 2…\n$ observation_period_start_date_plus_10_years <dttm> 2024-05-09, 1987-04-11, 2…\n```\n\n\n:::\n\n```{.r .cell-code}\ncdm$observation_period |> \n  dplyr::mutate(observation_days = date_count_between(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \"day\"))  |> \n  dplyr::mutate(observation_years = observation_days/ 365.25) |> \n  collect() |> \n  ggplot() +\n  geom_histogram(aes(observation_years), \n                 binwidth=2, colour=\"grey\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Piping and SQL\n\nAlthough piping queries has little impact on performance when using R with data in memory, when working with a database the SQL generated will differ when using multiple function calls (with a separate operation specified in each) instead of multiple operations within a single function call.\n\nFor example, a single mutate function above would generate the below SQL.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period |> \n  mutate(observation_period_start_plus_30_days = \n                add_days(observation_period_start_date, 30L),\n         observation_period_start_date_plus_10_years = \n                add_years(observation_period_start_date, 10L)) |> \n  select(\"observation_period_id\", \"person_id\", \n         \"observation_period_start_plus_30_days\",\n         \"observation_period_start_date_plus_10_years\") |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT\n  observation_period_id,\n  person_id,\n  DATE_ADD(observation_period_start_date, INTERVAL '30 day') AS observation_period_start_plus_30_days,\n  DATE_ADD(observation_period_start_date, INTERVAL '10 year') AS observation_period_start_date_plus_10_years\nFROM main.observation_period\n```\n\n\n:::\n:::\n\n\nWhereas the SQL will be different if using multiple mutate calls (now using a sub-query).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period |> \n  mutate(observation_period_start_plus_30_days = \n               add_days(observation_period_start_date, 30L)) |> \n  mutate(observation_period_start_date_plus_10_years = \n               add_years(observation_period_start_date, 10L)) |> \n  select(\"observation_period_id\", \"person_id\", \n         \"observation_period_start_plus_30_days\",\n         \"observation_period_start_date_plus_10_years\") |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT\n  observation_period_id,\n  person_id,\n  observation_period_start_plus_30_days,\n  DATE_ADD(observation_period_start_date, INTERVAL '10 year') AS observation_period_start_date_plus_10_years\nFROM (\n  SELECT\n    observation_period.*,\n    DATE_ADD(observation_period_start_date, INTERVAL '30 day') AS observation_period_start_plus_30_days\n  FROM main.observation_period\n) q01\n```\n\n\n:::\n:::\n\n:::\n\n## Statistical summaries\n\nWe can also use summarise for various other calculations\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person |> \n  summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE),\n            q05_year_of_birth = quantile(year_of_birth, 0.05, na.rm=TRUE),\n            mean_year_of_birth = round(mean(year_of_birth, na.rm=TRUE),0),\n            median_year_of_birth = median(year_of_birth, na.rm=TRUE),\n            q95_year_of_birth = quantile(year_of_birth, 0.95, na.rm=TRUE),\n            max_year_of_birth = max(year_of_birth, na.rm=TRUE)) |>  \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: ??\nColumns: 6\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmpq2lXaR\\file59a87f39708e.duckdb]\n$ min_year_of_birth    <int> 1923\n$ q05_year_of_birth    <dbl> 1927\n$ mean_year_of_birth   <dbl> 1971\n$ median_year_of_birth <dbl> 1970\n$ q95_year_of_birth    <dbl> 2018\n$ max_year_of_birth    <int> 2023\n```\n\n\n:::\n:::\n\n\nAs we've seen before, we can also quickly get results for various groupings or restrictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person |> \n   group_by(gender_concept_id) |> \n   summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE),\n            q25_year_of_birth = quantile(year_of_birth, 0.25, na.rm=TRUE),\n            median_year_of_birth = median(year_of_birth, na.rm=TRUE),\n            q75_year_of_birth = quantile(year_of_birth, 0.75, na.rm=TRUE),\n            max_year_of_birth = max(year_of_birth, na.rm=TRUE)) |> \n  left_join(cdm$concept, \n            by=c(\"gender_concept_id\" = \"concept_id\")) |> \n   collect() |> \n  ggplot(aes(x = concept_name, group = concept_name,\n             fill = concept_name)) +\n  geom_boxplot(aes(\n    lower = q25_year_of_birth, \n    upper = q75_year_of_birth, \n    middle = median_year_of_birth, \n    ymin = min_year_of_birth, \n    ymax = max_year_of_birth),\n    stat = \"identity\", width = 0.5) + \n  theme_bw()+ \n  theme(legend.position = \"none\") +\n  xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\n# Further reading\n\n-   ...",
    "supporting": [
      "ch_3_exploring_the_cdm_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}