{
  "hash": "343c790b305ae6658e200ae6d4157d74",
  "result": {
    "markdown": "## Exploring the CDM\n\nFor this chapter, lets continue using our example COVID-19 dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(dbplyr)\nlibrary(dplyr)\nlibrary(here)\nlibrary(CDMConnector)\nlibrary(ggplot2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndb<-dbConnect(duckdb::duckdb(), \n              dbdir = eunomiaDir(datasetName = \"synthea-covid19-10k\"))\ncdm <- cdm_from_con(db, \n                    cdm_schema = \"main\")\n```\n:::\n\n\n## Counting people\n\nThe OMOP CDM is person-centric, with the person table containing records to uniquely identify each person in the database. As each row refers to a unique person, we can quickly get a count of the number of individuals in the database like so\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  count() %>% \n  pull()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10754\n```\n:::\n:::\n\n\nThe person table also contains some demographic information, including a gender concept for each person. We can get a count grouped by this variable, but as this uses a concept we'll also need to join to the concept table to get the corresponding concept name for each concept id.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  group_by(gender_concept_id) %>% \n  count() %>% \n  left_join(cdm$concept, \n            by=c(\"gender_concept_id\" = \"concept_id\")) %>% \n              select(\"gender_concept_id\", \"concept_name\", \"n\") %>% \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n# Groups:   gender_concept_id [2]\n  gender_concept_id concept_name     n\n              <int> <chr>        <dbl>\n1              8532 FEMALE        5165\n2              8507 MALE          5589\n```\n:::\n:::\n\n\nThe observation period table contains records indicating spans of time over which clinical events can be reliably observed for the people in the person table. Someone can potentially have multiple observation periods. So say we wanted a count of people grouped by the year during which their first observation period started. We could do this like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_observation_period <- cdm$observation_period %>%\n    group_by(person_id) %>% \n    filter(row_number() == 1) %>% \n    computeQuery()\n\ncdm$person %>% \n  left_join(first_observation_period,\n            by = \"person_id\") %>% \n  mutate(observation_period_start_year=year(observation_period_start_date)) %>% \n  group_by(observation_period_start_year) %>% \n  count() %>% \n  collect() %>% \n  ggplot() +\n  geom_col(aes(observation_period_start_year, n)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Computing intermediate queries\n\nThe computeQuery() function will force the computation of a query. In the example above we use it to split up two queries; the first to keep the first observation period record for each individual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period %>%\n    group_by(person_id) %>% \n    filter(row_number() == 1) %>% \n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  observation_period_id,\n  person_id,\n  observation_period_start_date,\n  observation_period_end_date,\n  period_type_concept_id\nFROM (\n  SELECT *, ROW_NUMBER() OVER (PARTITION BY person_id) AS q03\n  FROM main.observation_period\n) q01\nWHERE (q03 = 1.0)\n```\n:::\n:::\n\n\nFollowed by a second query that left joins the person table with the result from the first (which is now in a temporary table), followed by extracted the year in which peoples first observation period starts and then, finally, a count by year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  left_join(first_observation_period,\n            by = \"person_id\") %>% \n  mutate(observation_period_start_year=year(observation_period_start_date)) %>% \n  group_by(observation_period_start_year) %>% \n  count() %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT observation_period_start_year, COUNT(*) AS n\nFROM (\n  SELECT\n    *,\n    EXTRACT(year FROM observation_period_start_date) AS observation_period_start_year\n  FROM (\n    SELECT\n      \"main.person\".*,\n      observation_period_id,\n      observation_period_start_date,\n      observation_period_end_date,\n      period_type_concept_id\n    FROM main.person AS \"main.person\"\n    LEFT JOIN dbplyr_001\n      ON (\"main.person\".person_id = dbplyr_001.person_id)\n  ) q01\n) q02\nGROUP BY observation_period_start_year\n```\n:::\n:::\n\n\nWe could, however, have done this without compute, with instead the SQL being done all at once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  left_join(cdm$observation_period %>%\n    group_by(person_id) %>% \n    filter(row_number() == 1),\n            by = \"person_id\") %>% \n  mutate(observation_period_start_year=year(observation_period_start_date)) %>% \n  group_by(observation_period_start_year) %>% \n  count() %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT observation_period_start_year, COUNT(*) AS n\nFROM (\n  SELECT\n    *,\n    EXTRACT(year FROM observation_period_start_date) AS observation_period_start_year\n  FROM (\n    SELECT\n      \"main.person\".*,\n      observation_period_id,\n      observation_period_start_date,\n      observation_period_end_date,\n      period_type_concept_id\n    FROM main.person AS \"main.person\"\n    LEFT JOIN (\n      SELECT\n        observation_period_id,\n        person_id,\n        observation_period_start_date,\n        observation_period_end_date,\n        period_type_concept_id\n      FROM (\n        SELECT *, ROW_NUMBER() OVER (PARTITION BY person_id) AS q03\n        FROM main.observation_period\n      ) q01\n      WHERE (q03 = 1.0)\n    ) RHS\n      ON (\"main.person\".person_id = RHS.person_id)\n  ) q02\n) q03\nGROUP BY observation_period_start_year\n```\n:::\n:::\n\n\nIn this case the SQL is not much more complicated than before. However, you can imagine that without forcing computation, the SQL associated with a series of data manipulations could quickly become unmanageable. So although we don't want to overuse computation of intermediate queries, it is often a necessity when writing analysis scripts.\n\nAn advantage of computing a query, is that we can then use the result for multiple subsequent queries. For example, say we want a count of condition occurrence and drug exposure records for those born before 1970. We could get these counts independently:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  filter(year_of_birth < \"1970\") %>% \n  select(\"person_id\") %>% \n  left_join(cdm$condition_occurrence,\n            by=\"person_id\") %>% \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpcBAPun\\file7cc1702327.duckdb]\n      n\n  <dbl>\n1  9305\n```\n:::\n\n```{.r .cell-code}\ncdm$person %>% \n  filter(year_of_birth < \"1970\") %>% \n  select(\"person_id\") %>% \n  left_join(cdm$drug_exposure,\n            by=\"person_id\") %>% \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpcBAPun\\file7cc1702327.duckdb]\n       n\n   <dbl>\n1 165681\n```\n:::\n:::\n\n\nBut we could have instead first subsetted the person table and then used the result for both queries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person_pre_1970 <- cdm$person %>% \n  filter(year_of_birth < \"1970\") %>% \n  computeQuery()\n\ncdm$person_pre_1970 %>% \n  select(\"person_id\") %>% \n  left_join(cdm$condition_occurrence,\n            by=\"person_id\") %>% \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpcBAPun\\file7cc1702327.duckdb]\n      n\n  <dbl>\n1  9305\n```\n:::\n\n```{.r .cell-code}\ncdm$person_pre_1970 %>% \n  select(\"person_id\") %>% \n  left_join(cdm$drug_exposure,\n            by=\"person_id\") %>% \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpcBAPun\\file7cc1702327.duckdb]\n       n\n   <dbl>\n1 165681\n```\n:::\n:::\n\n\nHere we've been using `computeQuery()` from the `CDMConnector` package. This function is an extension of the `compute()` function from `dplyr`, with `computeQuery()` providing greater consistency across its supported database management systems.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  tally() %>% \n  computeQuery()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<dbplyr_003> [1 x 1]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpcBAPun\\file7cc1702327.duckdb]\n      n\n  <dbl>\n1 10754\n```\n:::\n:::\n\n:::\n\n## Counting records\n\nWhat's the number of condition occurrence records per person in the database? We can find out like so\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  left_join(cdm$condition_occurrence %>% \n  group_by(person_id) %>% \n  count(name = \"condition_occurrence_records\"),\n  by=\"person_id\") %>% \n  mutate(condition_occurrence_records = if_else(\n    is.na(condition_occurrence_records), 0,\n    condition_occurrence_records)) %>% \n  group_by(condition_occurrence_records) %>%\n  count() %>% \n  collect() %>% \n  ggplot() +\n  geom_col(aes(condition_occurrence_records, n)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nHow about we were interested in getting record counts for some specific concepts related to COVID-19 symptoms?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$condition_occurrence %>% \n  filter(condition_concept_id %in% c(437663,437390,31967,\n                                     4289517,4223659, 312437,\n                                     434490,254761,77074)) %>% \n  group_by(condition_concept_id) %>% \n  count() %>% \n  left_join(cdm$concept,\n            by=c(\"condition_concept_id\" = \"concept_id\")) %>% \n  collect() %>% \n  ggplot() +\n  geom_col(aes(concept_name, n)) +\n  theme_bw()+\n  xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Vocabulary tables\n\nAbove we've got counts by specific concept IDs recorded in the condition occurrence table. What these IDs represent is described in the concept table. Here we have the name associate with the concept, along with other information such as it's domain and vocabulary id.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$concept %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: ??\nColumns: 10\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpcBAPun\\file7cc1702327.duckdb]\n$ concept_id       <int> 45756805, 45756804, 45756803, 45756802, 45756801, 457…\n$ concept_name     <chr> \"Pediatric Cardiology\", \"Pediatric Anesthesiology\", \"…\n$ domain_id        <chr> \"Provider\", \"Provider\", \"Provider\", \"Provider\", \"Prov…\n$ vocabulary_id    <chr> \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS…\n$ concept_class_id <chr> \"Physician Specialty\", \"Physician Specialty\", \"Physic…\n$ standard_concept <chr> \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\"…\n$ concept_code     <chr> \"OMOP4821938\", \"OMOP4821939\", \"OMOP4821940\", \"OMOP482…\n$ valid_start_date <date> 1970-01-01, 1970-01-01, 1970-01-01, 1970-01-01, 1970…\n$ valid_end_date   <date> 2099-12-31, 2099-12-31, 2099-12-31, 2099-12-31, 2099…\n$ invalid_reason   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n```\n:::\n:::\n\n\nOther vocabulary tables capture other information about concepts, such as the direct relationships between concepts (the concept relationship table) and hierarchical relationships between (the concept ancestor table).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$concept_relationship %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: ??\nColumns: 6\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpcBAPun\\file7cc1702327.duckdb]\n$ concept_id_1     <int> 35804314, 35804314, 35804314, 35804327, 35804327, 358…\n$ concept_id_2     <int> 912065, 42542145, 42542145, 35803584, 42542145, 42542…\n$ relationship_id  <chr> \"Has modality\", \"Has accepted use\", \"Is current in\", …\n$ valid_start_date <date> 2021-01-26, 2019-08-29, 2019-08-29, 2019-05-27, 2019…\n$ valid_end_date   <date> 2099-12-31, 2099-12-31, 2099-12-31, 2099-12-31, 2099…\n$ invalid_reason   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n```\n:::\n\n```{.r .cell-code}\ncdm$concept_ancestor %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: ??\nColumns: 4\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpcBAPun\\file7cc1702327.duckdb]\n$ ancestor_concept_id      <int> 375415, 727760, 735979, 438112, 529411, 14196…\n$ descendant_concept_id    <int> 4335743, 2056453, 41070383, 36566114, 4326940…\n$ min_levels_of_separation <int> 4, 1, 3, 2, 3, 3, 4, 3, 2, 5, 1, 3, 4, 2, 2, …\n$ max_levels_of_separation <int> 4, 1, 5, 3, 3, 6, 12, 3, 2, 10, 1, 3, 4, 2, 2…\n```\n:::\n:::\n\n\nMore information on the vocabulary tables (as well as other tables in the OMOP CDM version 5.3) can be found at <https://ohdsi.github.io/CommonDataModel/cdm53.html#Vocabulary_Tables>.\n:::\n\n## Working with dates\n\nDates are supported somewhat inconsistently by dbplyr but, as with `computeQuery()`, CDMConnector also provides some date functions that are tested to work across supported databases. We can use the `datediff()` function for example to calculate the difference between two dates. We can use this below to get the number of years observation periods last for.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period %>%\n  dplyr::mutate(observation_years = \n                  !!CDMConnector::datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"year\"))  %>% \n  collect() %>% \n  ggplot() +\n  geom_histogram(aes(observation_years), \n                 binwidth=2, colour=\"grey\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n## Statistical summaries\n\nWe can also use summarise for various other calculations\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE),\n            q05_year_of_birth = quantile(year_of_birth, 0.05, na.rm=TRUE),\n            mean_year_of_birth = round(mean(year_of_birth, na.rm=TRUE),0),\n            median_year_of_birth = median(year_of_birth, na.rm=TRUE),\n            q95_year_of_birth = quantile(year_of_birth, 0.95, na.rm=TRUE),\n            max_year_of_birth = max(year_of_birth, na.rm=TRUE)) %>%  \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: ??\nColumns: 6\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpcBAPun\\file7cc1702327.duckdb]\n$ min_year_of_birth    <int> 1923\n$ q05_year_of_birth    <dbl> 1927\n$ mean_year_of_birth   <dbl> 1971\n$ median_year_of_birth <dbl> 1970\n$ q95_year_of_birth    <dbl> 2018\n$ max_year_of_birth    <int> 2023\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Piping and SQL\n\nAlthough piping queries has little impact on performance when using R with data in memory, when working with a database the SQL generated will differ when using multiple function calls (with a separate operation specified in each) instead of multiple operations within a single function call.\n\nFor example, a single mutate function above would generate the below SQL.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period %>%\n  mutate(observation_days = !!datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"day\"),\n        observation_years = !!datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"year\")) %>% \n  select(\"observation_period_id\", \"person_id\", \n         \"observation_days\",\"observation_years\") %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  observation_period_id,\n  person_id,\n  datediff('day', observation_period_start_date, observation_period_end_date) AS observation_days,\n  FLOOR((date_part('year', observation_period_end_date) * 10000 + date_part('month', observation_period_end_date) * 100 + date_part('day', observation_period_end_date) -\n(date_part('year', observation_period_start_date) * 10000 + date_part('month', observation_period_start_date) * 100 + date_part('day', observation_period_start_date))) / 10000) AS observation_years\nFROM main.observation_period\n```\n:::\n:::\n\n\nWhereas the SQL will be different if using multiple mutate calls (now using a sub-query).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period %>%\n  mutate(observation_days = !!datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"day\")) %>% \n  mutate(observation_years = !!datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"year\")) %>% \n  select(\"observation_period_id\", \"person_id\", \n         \"observation_days\",\"observation_years\") %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  observation_period_id,\n  person_id,\n  observation_days,\n  FLOOR((date_part('year', observation_period_end_date) * 10000 + date_part('month', observation_period_end_date) * 100 + date_part('day', observation_period_end_date) -\n(date_part('year', observation_period_start_date) * 10000 + date_part('month', observation_period_start_date) * 100 + date_part('day', observation_period_start_date))) / 10000) AS observation_years\nFROM (\n  SELECT\n    *,\n    datediff('day', observation_period_start_date, observation_period_end_date) AS observation_days\n  FROM main.observation_period\n) q01\n```\n:::\n:::\n\n:::\n\nAs we've seen before, we can also quickly get results for various groupings or restrictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n   group_by(gender_concept_id) %>% \n   summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE),\n            q25_year_of_birth = quantile(year_of_birth, 0.25, na.rm=TRUE),\n            median_year_of_birth = median(year_of_birth, na.rm=TRUE),\n            q75_year_of_birth = quantile(year_of_birth, 0.75, na.rm=TRUE),\n            max_year_of_birth = max(year_of_birth, na.rm=TRUE)) %>% \n  left_join(cdm$concept, \n            by=c(\"gender_concept_id\" = \"concept_id\")) %>% \n   collect() %>% \n  ggplot(aes(x = concept_name, group = concept_name,\n             fill = concept_name)) +\n  geom_boxplot(aes(\n    lower = q25_year_of_birth, \n    upper = q75_year_of_birth, \n    middle = median_year_of_birth, \n    ymin = min_year_of_birth, \n    ymax = max_year_of_birth),\n    stat = \"identity\", width = 0.5) + \n  theme_bw()+ \n  theme(legend.position = \"none\") +\n  xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "ch_3_exploring_the_cdm_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}